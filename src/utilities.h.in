/*=========================================================================

  Program:  sampsim
  Module:   utilities.h
  Language: C++

  Author: Patrick Emond <emondpd@mcmaster.ca>

=========================================================================*/
//
// .SECTION Description
// A utilities header to include typedefs, macros, global functions, etc.
//

#ifndef __utilities_h
#define __utilities_h

#define SAMPSIM_VERSION_MAJOR @SAMPSIM_VERSION_MAJOR@
#define SAMPSIM_VERSION_MINOR @SAMPSIM_VERSION_MINOR@
#define SAMPSIM_VERSION_PATCH @SAMPSIM_VERSION_PATCH@

#define SAMPSIM_ROOT_DIR "@SAMPSIM_ROOT_DIR@"
#define SAMPSIM_AUX_DIR "@SAMPSIM_AUX_DIR@"
#define SAMPSIM_SRC_DIR "@SAMPSIM_SRC_DIR@"

#include <algorithm>
#include <ctime>
#include <cctype>
#include <iostream>
#include <random>
#include <sstream>
#include <stdarg.h>
#include <stdio.h>
#include <time.h>
#include <unistd.h>
#include <vector>

/**
 * @addtogroup sampsim
 * @{
 */

namespace sampsim
{
  class utilities
  {
  public:
    inline static void output( std::string message, ... )
    {
      va_list args;  // Pointer to optional arguments
      va_start( args, message );
      
      char buffer[256];
      vsprintf( buffer, message.c_str(), args );

      double elapsed = (float)( clock() - utilities::start_time ) / CLOCKS_PER_SEC;
      int hours = floor( elapsed / 3600 );
      int minutes = floor( ( elapsed - hours * 3600 ) / 60 );
      double seconds = elapsed - hours * 3600 - minutes * 60;
      char time[32];
      sprintf( time, "[%d:%02d:%05.2f]", hours, minutes, seconds );

      std::cout << time << " " << buffer << std::endl;
    }

    inline static std::string exec( const char* command )
    {
      FILE* pipe = popen( command, "r" );
      if( !pipe ) return "ERROR";
      char buffer[128];
      std::string result = "";
      while( !feof( pipe ) ) if( fgets( buffer, 128, pipe ) != NULL ) result += buffer;
      pclose( pipe );
      return result;
    }

    inline static bool file_exists( std::string filename )
    {
      if( filename.empty() ) return false;
      return access( filename.c_str(), R_OK )  == 0;
    }

    inline static std::string get_file_extension( std::string filename )
    {
      std::string::size_type dot_pos = filename.rfind( "." );
      std::string extension = ( dot_pos == std::string::npos ) ? "" : filename.substr( dot_pos );
      return extension;
    }

    inline static std::string get_filename_path( std::string filename )
    {
      std::string::size_type slash_pos = filename.rfind("/");
      if( slash_pos != std::string::npos )
      {
        std::string path = filename.substr( 0, slash_pos );
        if( path.size() == 2 && path[1] == ':' )
        {
          return path + '/';
        }
        if( path.size() == 0 )
        {
          return "/";
        }
        return path;
      }
      else
      {
        return "";
      }
    }

    inline static std::string get_filename_name( std::string filename )
    {
      std::string::size_type slash_pos = filename.find_last_of("/");
      if( slash_pos != std::string::npos )
      {
        return filename.substr( slash_pos + 1 );
      }
      else
      {
        return filename;
      }
    }

    inline static std::vector< std::string > explode( std::string str, std::string separator )
    {
      std::vector< std::string > results;
      int found = str.find_first_of( separator );
      while( found != std::string::npos )
      {
        if( found > 0 ) results.push_back( str.substr( 0, found ) );
        str = str.substr( found + 1 );
        found = str.find_first_of( separator );
      }
      if( str.length() > 0 ) results.push_back( str );
      return results;
    }

    inline static std::string &ltrim( std::string &s )
    {
      s.erase(
        s.begin(), std::find_if(
          s.begin(), s.end(), std::not1(
            std::ptr_fun<int, int>( std::isspace ) ) ) );
      return s;
    }

    inline static std::string &rtrim( std::string &s )
    {
      s.erase(
        std::find_if(
          s.rbegin(), s.rend(), std::not1(
            std::ptr_fun<int, int>( std::isspace ) ) ).base(), s.end() );
      return s;
    }

    inline static std::string &trim(std::string &s)
    {
      return ltrim(rtrim(s));
    }

    inline static unsigned int random( unsigned int min, unsigned int max )
    {
      return random_engine() % ( max - min + 1 ) + min;
    }

    inline static double random()
    {
      return static_cast< double >( random_engine() - random_engine.min() ) /
             static_cast< double >( random_engine.max() - random_engine.min() );
    }

    struct safe_delete_type
    {
      template <typename T>
      void operator()( T *&p ) { if( p ) { delete p; p = 0; } };
    };

    static std::mt19937 random_engine;
    static safe_delete_type safe_delete;
    static bool verbose;
    static int household_index;
    static clock_t start_time;
  };
}

#endif // __utilities_h
