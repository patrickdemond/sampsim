/*=========================================================================

  Program:  sampsim
  Module:   utilities.h
  Language: C++

  Author: Patrick Emond <emondpd@mcmaster.ca>

=========================================================================*/
//
// .SECTION Description
// A utilities header to include typedefs, macros, global functions, etc.
//

#ifndef __sampsim_utilities_h
#define __sampsim_utilities_h

#define SAMPSIM_VERSION_MAJOR @SAMPSIM_VERSION_MAJOR@
#define SAMPSIM_VERSION_MINOR @SAMPSIM_VERSION_MINOR@
#define SAMPSIM_VERSION_PATCH @SAMPSIM_VERSION_PATCH@

#define SAMPSIM_ROOT_DIR "@SAMPSIM_ROOT_DIR@"
#define SAMPSIM_AUX_DIR "@SAMPSIM_AUX_DIR@"
#define SAMPSIM_SRC_DIR "@SAMPSIM_SRC_DIR@"

#include <algorithm>
#include <ctime>
#include <cctype>
#include <iomanip>
#include <iostream>
#include <map>
#include <random>
#include <sstream>
#include <stdarg.h>
#include <stdio.h>
#include <time.h>
#include <unistd.h>
#include <vector>

#include "coordinate.h"

/**
 * @addtogroup sampsim
 * @{
 */

/**
 * @namespace sampsim
 * @brief A namespace containing all of SampSim's library classes
 */
namespace sampsim
{
  class town;
  class tile;
  class building;
  class household;
  class individual;

  /**
   * @typedef town_list_type
   */
  typedef std::vector< town* > town_list_type;

  /**
   * @typedef tile_list_type
   */
  typedef std::map< std::pair< unsigned int, unsigned int >, tile* > tile_list_type;

  /**
   * @typedef building_list_type
   */
  typedef std::vector< building* > building_list_type;

  /**
   * @typedef household_list_type
   */
  typedef std::vector< household* > household_list_type;

  /**
   * @typedef individual_list_type
   */
  typedef std::vector< individual* > individual_list_type;

  /**
   * @typedef coordinate_list_type
   */
  typedef std::vector< coordinate > coordinate_list_type;

  /**
   * @enum age_type
   * A list of all possible ways to select inviduals by age
   */
  enum age_type
  {
    UNKNOWN_AGE_TYPE = 0,
    ANY_AGE,
    ADULT,
    CHILD
  };

  /**
   * Converts the name of an age type to its enum value
   */
  inline static age_type get_age_type( const std::string name )
  {
    if( "either" == name ) return ANY_AGE;
    else if( "adult" == name ) return ADULT;
    else if( "child" == name ) return CHILD;
    return UNKNOWN_AGE_TYPE;
  }

  /**
   * Converts the enum value of an age type to its name
   */
  inline static std::string get_age_type_name( const age_type type )
  {
    if( ANY_AGE == type ) return "either";
    else if( ADULT == type ) return "adult";
    else if( CHILD == type ) return "child";
    return "unknown";
  }

  /**
   * @enum sex_type
   * A list of all possible ways to select individuals by sex
   */
  enum sex_type
  {
    UNKNOWN_SEX_TYPE = 0,
    ANY_SEX,
    FEMALE,
    MALE
  };

  /**
   * Converts the name of a sex type to its enum value
   */
  inline static sex_type get_sex_type( const std::string name )
  {
    if( "either" == name ) return ANY_SEX;
    else if( "female" == name ) return FEMALE;
    else if( "male" == name ) return MALE;
    return UNKNOWN_SEX_TYPE;
  }

  /**
   * Converts the enum value of a sex type to its name
   */
  inline static std::string get_sex_type_name( const sex_type type )
  {
    if( ANY_SEX == type ) return "either";
    else if( FEMALE == type ) return "female";
    else if( MALE == type ) return "male";
    return "unknown";
  }

  /**
   * @class utilities
   * @author Patrick Emond <emondpd@mcmaster.ca>
   * @brief A class of various utility functions (all inline static functions)
   */
  class utilities
  {
  public:
    /**
     * Returns a string representation of the software version
     */
    inline static std::string get_version()
    {
      std::stringstream stream;
      stream << SAMPSIM_VERSION_MAJOR << "." << SAMPSIM_VERSION_MINOR << "." << SAMPSIM_VERSION_PATCH;
      return stream.str();
    }

    /**
     * Outputs text to the standard output
     * 
     * This function will prefix the output with the application's running time
     */
    inline static void output( std::string message, va_list args )
    {
      char buffer[512];
      vsprintf( buffer, message.c_str(), args );

      double elapsed = (float)( clock() - utilities::start_time ) / CLOCKS_PER_SEC;
      int hours = floor( elapsed / 3600 );
      int minutes = floor( ( elapsed - hours * 3600 ) / 60 );
      double seconds = elapsed - hours * 3600 - minutes * 60;
      char time[32];
      sprintf( time, "[%d:%02d:%05.2f]", hours, minutes, seconds );

      std::cout << time << " " << buffer << std::endl;
    }

    /**
     * Outputs text to the standard output
     * 
     * This function will prefix the output with the application's running time
     */
    inline static void output( std::string message, ... )
    {
      va_list args;  // Pointer to optional arguments
      va_start( args, message );
      utilities::output( message, args );
    }

    /**
     * Executes an operation on the command line and returns the command's output
     */
    inline static std::string exec( const std::string command )
    {
      FILE* pipe = popen( command.c_str(), "r" );
      if( !pipe ) return "ERROR";
      char buffer[128];
      std::string result = "";
      while( !feof( pipe ) ) if( fgets( buffer, 128, pipe ) != NULL ) result += buffer;
      pclose( pipe );
      return 0 < result.length() ? result.substr( 0, result.length() - 1 ) : "";
    }

    /**
     * Returns whether a file exists
     */
    inline static bool file_exists( std::string filename )
    {
      if( filename.empty() ) return false;
      return access( filename.c_str(), R_OK )  == 0;
    }

    /**
     * Returns a file's extension (the string after the last . in the filename)
     */
    inline static std::string get_file_extension( std::string filename )
    {
      std::string::size_type dot_pos = filename.rfind( "." );
      std::string extension = ( dot_pos == std::string::npos ) ? "" : filename.substr( dot_pos );
      return extension;
    }

    /**
     * Returns the path from a full path and filename
     */
    inline static std::string get_filename_path( std::string filename )
    {
      std::string::size_type slash_pos = filename.rfind("/");
      if( slash_pos != std::string::npos )
      {
        std::string path = filename.substr( 0, slash_pos );
        if( path.size() == 2 && path[1] == ':' )
        {
          return path + '/';
        }
        if( path.size() == 0 )
        {
          return "/";
        }
        return path;
      }
      else
      {
        return "";
      }
    }

    /**
     * Returns the file name from a full path and filename
     */
    inline static std::string get_filename_name( std::string filename )
    {
      std::string::size_type slash_pos = filename.find_last_of("/");
      if( slash_pos != std::string::npos )
      {
        return filename.substr( slash_pos + 1 );
      }
      else
      {
        return filename;
      }
    }

    /**
     * Divides a string by the provided separator, returning the results as a vector of strings
     */
    inline static std::vector< std::string > explode( std::string str, std::string separator )
    {
      std::vector< std::string > results;
      int found = str.find_first_of( separator );
      while( found != std::string::npos )
      {
        if( found > 0 ) results.push_back( str.substr( 0, found ) );
        str = str.substr( found + 1 );
        found = str.find_first_of( separator );
      }
      if( str.length() > 0 ) results.push_back( str );
      return results;
    }

    /**
     * Removes all space characters (as defined by std::isspace) from the left side of a string
     */
    inline static std::string &ltrim( std::string &s )
    {
      s.erase(
        s.begin(), std::find_if(
          s.begin(), s.end(), std::not1(
            std::ptr_fun<int, int>( std::isspace ) ) ) );
      return s;
    }

    /**
     * Removes all space characters (as defined by std::isspace) from the right side of a string
     */
    inline static std::string &rtrim( std::string &s )
    {
      s.erase(
        std::find_if(
          s.rbegin(), s.rend(), std::not1(
            std::ptr_fun<int, int>( std::isspace ) ) ).base(), s.end() );
      return s;
    }

    /**
     * Removes all space characters (as defined by std::isspace) from both sides of a string
     */
    inline static std::string &trim(std::string &s)
    {
      return ltrim(rtrim(s));
    }

    /**
     * Returns a random integer between the min and max values, inclusive
     */
    inline static unsigned int random( unsigned int min, unsigned int max )
    {
      return random_engine() % ( max - min + 1 ) + min;
    }

    /**
     * Returns a random value in [0, 1)
     */
    inline static double random()
    {
      return static_cast< double >( random_engine() - random_engine.min() ) /
             static_cast< double >( random_engine.max() - random_engine.min() + 1 );
    }

    /**
     * @struct safe_delete_type
     * @brief Used for safely deleting memory
     */
    struct safe_delete_type
    {
      /**
       * Overrides the () operator in order to allow instance of this struct to act as a
       * safe-delete mechanism
       */
      template <typename T>
      void operator()( T *&p ) { if( p ) { delete p; p = 0; } };
    };

    /**
     * The random engine used by the random functions
     */
    static std::mt19937 random_engine;
    
    /**
     * A struct instance used to safely delete memory
     */
    static safe_delete_type safe_delete;
    
    /**
     * Whether to output additional messages during execution
     */
    static bool verbose;
    
    /**
     * A running household count used to identify households in CSV output files
     */
    static unsigned int household_index;

    /**
     * A clock used to track execution time
     */
    static clock_t start_time;
  };
}

/** @} end of doxygen group */

#endif // __utilities_h
